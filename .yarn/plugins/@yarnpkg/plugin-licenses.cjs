/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-licenses",
factory: function (require) {
var plugin=(()=>{var oe=Object.create,M=Object.defineProperty;var re=Object.getOwnPropertyDescriptor;var ae=Object.getOwnPropertyNames,_=Object.getOwnPropertySymbols,ce=Object.getPrototypeOf,z=Object.prototype.hasOwnProperty,le=Object.prototype.propertyIsEnumerable;var K=(e,n,t)=>n in e?M(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,F=(e,n)=>{for(var t in n||(n={}))z.call(n,t)&&K(e,t,n[t]);if(_)for(var t of _(n))le.call(n,t)&&K(e,t,n[t]);return e};var de=e=>M(e,"__esModule",{value:!0});var l=e=>{if(typeof require!="undefined")return require(e);throw new Error('Dynamic require of "'+e+'" is not supported')};var E=(e,n)=>{for(var t in n)M(e,t,{get:n[t],enumerable:!0})},pe=(e,n,t)=>{if(n&&typeof n=="object"||typeof n=="function")for(let i of ae(n))!z.call(e,i)&&i!=="default"&&M(e,i,{get:()=>n[i],enumerable:!(t=re(n,i))||t.enumerable});return e},d=e=>pe(de(M(e!=null?oe(ce(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var ve={};E(ve,{default:()=>we});var ee=d(l("@yarnpkg/cli")),x=d(l("@yarnpkg/core")),w=d(l("clipanion"));var o=d(l("@yarnpkg/core")),f=d(l("@yarnpkg/fslib"));var $={};E($,{fs:()=>me,getPackagePath:()=>fe});var q=d(l("@yarnpkg/plugin-pnp")),S=d(l("@yarnpkg/core")),j=d(l("@yarnpkg/fslib")),J=d(l("@yarnpkg/libzip")),fe=async(e,n)=>{ue(e);let t=S.structUtils.convertPackageToLocator(n),i={name:S.structUtils.stringifyIdent(t),reference:t.reference},s=R.getPackageInformation(i);if(!s)return null;let{packageLocation:a}=s;return a},R,ue=e=>{R||(R=module.require((0,q.getPnpPath)(e).cjs))},me=new j.VirtualFS({baseFs:new j.ZipOpenFS({libzip:(0,J.getLibzipSync)(),readOnlyArchives:!0})});var A={};E(A,{fs:()=>Pe,getPackagePath:()=>ge});var W=d(l("@yarnpkg/core")),Y=d(l("@yarnpkg/parsers")),y=d(l("@yarnpkg/fslib")),ge=async(e,n)=>{await he(e);let t=W.structUtils.convertPackageToLocator(n),i=H[W.structUtils.stringifyLocator(t)];if(!i)return null;let s=i.locations[0];return s?y.ppath.join(e.cwd,s):e.cwd},H,he=async e=>{if(!H){let n=y.ppath.join(e.configuration.projectCwd,y.Filename.nodeModules,".yarn-state.yml");H=(0,Y.parseSyml)(await y.xfs.readFilePromise(n,"utf8"))}},Pe=y.xfs;var B=e=>{switch(e){case"pnp":return $;case"node-modules":return A;default:throw new Error("Unsupported linker")}};var Se=f.npath.basename(__dirname)==="@yarnpkg"?f.ppath.join(f.npath.toPortablePath(__dirname),"../.."):f.ppath.join(f.npath.toPortablePath(__dirname),".."),Z=async(e,n,t,i,s)=>{let a={},g={children:a},r=await G(e,t,i),c=B(e.configuration.get("nodeLinker"));for(let[p,m]of r.entries()){let h=await c.getPackagePath(e,m);if(h===null)continue;let v=JSON.parse(await c.fs.readFilePromise(f.ppath.join(h,f.Filename.manifest),"utf8")),{license:u,url:N,vendorName:T,vendorUrl:I}=ke(v);a[u]||(a[u]={value:o.formatUtils.tuple(o.formatUtils.Type.NO_HINT,u),children:{}});let L=o.structUtils.convertPackageToLocator(m),P=o.formatUtils.tuple(o.formatUtils.Type.DEPENDENT,{locator:L,descriptor:p}),k=s?{}:F(F(F({},N?{url:{value:o.formatUtils.tuple(o.formatUtils.Type.NO_HINT,V("URL",N,n))}}:{}),T?{vendorName:{value:o.formatUtils.tuple(o.formatUtils.Type.NO_HINT,V("VendorName",T,n))}}:{}),I?{vendorUrl:{value:o.formatUtils.tuple(o.formatUtils.Type.NO_HINT,V("VendorUrl",I,n))}}:{}),ne={value:P,children:k},ie=o.structUtils.stringifyLocator(L),se=a[u].children;se[ie]=ne}return g},G=async(e,n,t)=>{let i=new Map,s;if(n){if(t){for(let c of e.workspaces)c.manifest.devDependencies.clear();let r=await o.Cache.find(e.configuration);await e.resolveEverything({report:new o.ThrowReport,cache:r})}s=e.storedDescriptors.values()}else s=e.workspaces.flatMap(r=>{let c=[r.anchoredDescriptor];for(let[p,m]of r.dependencies.entries())t&&r.manifest.devDependencies.has(p)||c.push(m);return c});let a=o.miscUtils.sortMap(s,[r=>o.structUtils.stringifyIdent(r),r=>o.structUtils.isVirtualDescriptor(r)?"0":"1",r=>r.range]),g=new Set;for(let r of a.values()){let c=e.storedResolutions.get(r.descriptorHash);if(!c)continue;let p=e.storedPackages.get(c);if(!p)continue;let{descriptorHash:m}=o.structUtils.isVirtualDescriptor(r)?o.structUtils.devirtualizeDescriptor(r):r;g.has(m)||(g.add(m),i.set(r,p))}return i},ke=e=>{let{license:n,licenses:t,repository:i,homepage:s,author:a}=e;return{license:(()=>{if(n)return C(n);if(t){if(!Array.isArray(t))return C(t);if(t.length===1)return C(t[0]);if(t.length>1)return`(${t.map(C).join(" OR ")})`}return Q})(),url:(i==null?void 0:i.url)||s,vendorName:a==null?void 0:a.name,vendorUrl:s||(a==null?void 0:a.url)}},Q="UNKNOWN",C=e=>(typeof e!="string"?e.type:e)||Q,V=(e,n,t)=>t?n:`${e}: ${n}`,X=async(e,n,t)=>{let i=await G(e,n,t),s=B(e.configuration.get("nodeLinker")),a=new Map;for(let r of i.values()){let c=await s.getPackagePath(e,r);if(c===null)continue;let p=JSON.parse(await s.fs.readFilePromise(f.ppath.join(c,f.Filename.manifest),"utf8")),h=(await s.fs.readdirPromise(c,{withFileTypes:!0})).filter(P=>P.isFile()).map(({name:P})=>P),v=h.find(P=>{let k=P.toLowerCase();return k==="license"||k.startsWith("license.")||k==="unlicense"||k.startsWith("unlicense.")});if(!v)continue;let u=await s.fs.readFilePromise(f.ppath.join(c,v),"utf8"),N=h.find(P=>{let k=P.toLowerCase();return k==="notice"||k.startsWith("notice.")}),T;N&&(T=await s.fs.readFilePromise(f.ppath.join(c,N),"utf8"));let I=T?`${u}

NOTICE

${T}`:u,L=a.get(I);L?L.set(p.name,p):a.set(I,new Map([[p.name,p]]))}let g=`THE FOLLOWING SETS FORTH ATTRIBUTION NOTICES FOR THIRD PARTY SOFTWARE THAT MAY BE CONTAINED IN PORTIONS OF THE ${String(e.topLevelWorkspace.manifest.raw.name).toUpperCase().replace(/-/g," ")} PRODUCT.

`;for(let[r,c]of a.entries()){g+=`-----

`;let p=[],m=[];for(let{name:v,repository:u}of c.values())p.push(v),(u==null?void 0:u.url)&&m.push(c.size===1?u.url:`${u.url} (${v})`);let h=[];h.push(`The following software may be included in this product: ${p.join(", ")}.`),m.length>0&&h.push(`A copy of the source code may be downloaded from ${m.join(", ")}.`),h.push("This software contains the following license and notice below:"),g+=`${h.join(" ")}

`,g+=`${r.trim()}

`}return g};var U=class extends w.Command{constructor(){super(...arguments);this.recursive=w.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=w.Option.Boolean("--production",!1,{description:"Exclude development dependencies"});this.json=w.Option.Boolean("--json",!1,{description:"Format output as JSON"});this.excludeMetadata=w.Option.Boolean("--exclude-metadata",!1,{description:"Exclude dependency metadata from output"})}async execute(){let n=await x.Configuration.find(this.context.cwd,this.context.plugins),{project:t,workspace:i}=await x.Project.find(n,this.context.cwd);if(!i)throw new ee.WorkspaceRequiredError(t.cwd,this.context.cwd);await t.restoreInstallState();let s=await Z(t,this.json,this.recursive,this.production,this.excludeMetadata);x.treeUtils.emitTree(s,{configuration:n,stdout:this.context.stdout,json:this.json,separators:1})}};U.paths=[["licenses","list"]],U.usage=w.Command.Usage({description:"display the licenses for all packages in the project",details:`
      This command prints the license information for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the listing will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the listing will exclude development dependencies.
    `,examples:[["List all licenses of direct dependencies","$0 licenses list"],["List all licenses of direct and transitive dependencies","$0 licenses list --recursive"],["List all licenses of production dependencies only","$0 licenses list --production"]]});var te=d(l("@yarnpkg/cli")),D=d(l("@yarnpkg/core")),b=d(l("clipanion"));var O=class extends b.Command{constructor(){super(...arguments);this.recursive=b.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=b.Option.Boolean("--production",!1,{description:"Exclude development dependencies"})}async execute(){let n=await D.Configuration.find(this.context.cwd,this.context.plugins),{project:t,workspace:i}=await D.Project.find(n,this.context.cwd);if(!i)throw new te.WorkspaceRequiredError(t.cwd,this.context.cwd);await t.restoreInstallState();let s=await X(t,this.recursive,this.production);this.context.stdout.write(s)}};O.paths=[["licenses","generate-disclaimer"]],O.usage=b.Command.Usage({description:"display the license disclaimer including all packages in the project",details:`
      This command prints the license disclaimer for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the disclaimer will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the disclaimer will exclude development dependencies.
    `,examples:[["Include licenses of direct dependencies","$0 licenses generate-disclaimer"],["Include licenses of direct and transitive dependencies","$0 licenses generate-disclaimer --recursive"],["Include licenses of production dependencies only","$0 licenses list --production"]]});var ye={commands:[U,O]},we=ye;return ve;})();
return plugin;
}
};
