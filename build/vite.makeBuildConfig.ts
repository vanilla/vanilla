import { UserConfig, mergeConfig } from "vite";
import { getAddonKeyFromChunkID, isAddonEntry, makeViteCommonConfig } from "./vite.commonConfig";

import { VANILLA_ROOT } from "./scripts/env";
import { VanillaManifestPlugin } from "./VanillaManifestPlugin";
import path from "path";
import reactPlugin from "@vitejs/plugin-react-swc";

/**
 * Global map to track module ID to addon relationships during the build process.
 * This allows us to determine which addon a module belongs to, even when processing
 * derived assets like CSS files that may not have obvious addon paths in their metadata.
 *
 * Key: Module ID (file path)
 * Value: Addon name
 */
const moduleToAddonMap = new Map<string, string>();

/**
 * Creates a Vite build configuration with custom addon-aware asset handling.
 *
 * This configuration includes a custom plugin system that tracks module-to-addon relationships
 * during the build process, enabling proper scoping of CSS assets to their respective addons.
 * This ensures that theme-specific styles are isolated and don't cause conflicts when
 * different themes are enabled.
 */
export function makeViteBuildConfig(buildSection: string, entryHtmlFile: string): UserConfig {
    const buildConfig: UserConfig = {
        clearScreen: false,
        experimental: {
            renderBuiltUrl(filename: string, { hostType }: { hostType: "js" | "css" | "html" }) {
                return { relative: true };
            },
        },
        cacheDir: path.join(VANILLA_ROOT, "node_modules/.vite"),
        esbuild: {
            legalComments: "external",
        },
        resolve: {
            alias: [
                {
                    find: "@storybook/test",
                    replacement: path.resolve(VANILLA_ROOT, "dont-import-storybook-outside-of-storybook"),
                },
                {
                    find: "@testing-library.*",
                    replacement: path.resolve(VANILLA_ROOT, "dont-import-testinglibrary-outside-of-tests"),
                },
            ],
        },
        plugins: [
            reactPlugin({
                plugins: [
                    [
                        "@swc/plugin-emotion",
                        {
                            // default is true. It will be disabled when build type is production.
                            sourceMap: false,
                            // default is 'dev-only'.
                            autoLabel: "always",
                            // default is '[local]'.
                            // Allowed values: `[local]` `[filename]` and `[dirname]`
                            // This option only works when autoLabel is set to 'dev-only' or 'always'.
                            // It allows you to define the format of the resulting label.
                            // The format is defined via string where variable parts are enclosed in square brackets [].
                            // For example labelFormat: "my-classname--[local]", where [local] will be replaced with the name of the variable the result is assigned to.
                            labelFormat: "[filename]-[local]",
                        },
                    ],
                ],
            }),
            /**
             * Custom Vite plugin to track module-to-addon relationships during the build process.
             *
             * This plugin solves the problem where CSS assets generated by Vite don't have
             * `originalFileNames` populated, making it impossible to determine which addon
             * they belong to using the standard Rollup/Vite metadata.
             *
             * The plugin works by:
             * 1. Intercepting module resolution and loading to build a comprehensive map
             * 2. Tracking both direct addon modules and propagating addon info through imports
             * 3. Making this information available to the `assetFileNames` function
             */
            {
                name: "track-module-addons",
                enforce: "pre", // Run early to catch all module resolutions

                buildStart() {
                    // Reset the tracking map for each build to avoid stale data
                    moduleToAddonMap.clear();
                },

                resolveId(id, importer) {
                    /**
                     * Track addon relationships during module resolution.
                     * This hook is called for every import statement and allows us to
                     * build a comprehensive map of which modules belong to which addons.
                     */
                    if (id && importer) {
                        const importerAddon = getAddonKeyFromChunkID(importer);
                        const moduleAddon = getAddonKeyFromChunkID(id);

                        // Propagate addon information from importer to imported module
                        // This handles cases where a module doesn't have an obvious addon path
                        // but is imported by a module that does (e.g., relative imports)
                        if (importerAddon && !moduleAddon) {
                            moduleToAddonMap.set(id, importerAddon);
                        } else if (moduleAddon) {
                            // Direct addon detection - module path clearly indicates addon
                            moduleToAddonMap.set(id, moduleAddon);
                        }
                    }
                    return null; // Don't interfere with Vite's normal module resolution
                },

                load(id) {
                    /**
                     * Additional tracking during the load phase.
                     * This catches any modules that might have been missed during resolution
                     * and ensures we have comprehensive coverage of all addon modules.
                     */
                    const addon = getAddonKeyFromChunkID(id);
                    if (addon) {
                        moduleToAddonMap.set(id, addon);
                    }
                    return null; // Don't interfere with Vite's normal module loading
                },
            },
            VanillaManifestPlugin(buildSection),
        ],
        build: {
            watch: null,
            chunkSizeWarningLimit: 1000,
            // We have our own manifest plugin.
            manifest: false,
            sourcemap: false,
            modulePreload: false,
            rollupOptions: {
                input: entryHtmlFile,
                onwarn: (warning, warn) => {
                    if (warning.message.includes("The comment will be removed to avoid issues")) {
                        return;
                    }
                    warn(warning);
                },
                output: {
                    inlineDynamicImports: false,
                    compact: true,
                    minifyInternalExports: true,
                    generatedCode: "es2015",
                    entryFileNames(chunkInfo) {
                        return "entries/[name].[hash].min.js";
                    },
                    assetFileNames(chunkInfo) {
                        /**
                         * Custom asset file naming logic for CSS files to ensure proper addon scoping.
                         *
                         * This function determines where CSS assets should be placed in the output directory.
                         * CSS files belonging to addons should go to `chunks/addons/{addonName}/` while
                         * global CSS files go to the general `assets/` directory.
                         */
                        if (chunkInfo.names.some((name) => name.endsWith(".css"))) {
                            let addonName: string | null = null;
                            const cssFileName = chunkInfo.names[0];

                            /**
                             * Primary approach: Use Rollup's originalFileNames metadata
                             * This contains the original source file paths that contributed to this asset.
                             * However, for CSS assets, this is often empty due to how Vite processes stylesheets.
                             */
                            if (chunkInfo.originalFileNames && chunkInfo.originalFileNames.length > 0) {
                                addonName =
                                    chunkInfo.originalFileNames
                                        ?.map((name) => getAddonKeyFromChunkID(name))
                                        ?.filter((val) => val)?.[0] ?? null;
                            }

                            /**
                             * Fallback approach: Use our custom module tracking
                             * When originalFileNames is empty (common for CSS), we fall back to our
                             * module-to-addon mapping built during the resolution/load phases.
                             *
                             * We look for any SCSS/CSS modules in our map and use the first addon
                             * we find. This works because within a single CSS asset, all contributing
                             * modules should belong to the same addon due to how bundling works.
                             */
                            if (!addonName) {
                                for (const [moduleId, mappedAddon] of moduleToAddonMap.entries()) {
                                    // Focus on stylesheet modules as they're most likely to be the source
                                    // of the CSS asset we're currently naming
                                    if (moduleId.endsWith(".scss") || moduleId.endsWith(".css")) {
                                        addonName = mappedAddon;
                                        break; // Use first match - all should be from same addon
                                    }
                                }
                            }

                            /**
                             * Apply addon-specific path structure if we detected an addon,
                             * otherwise use the default global asset path
                             */
                            if (addonName) {
                                return `chunks/addons/${addonName}/[name].[hash].css`;
                            }
                        }

                        // Default path for non-CSS assets or CSS that doesn't belong to any addon
                        return `assets/[name].[hash][extname]`;
                    },
                    chunkFileNames(chunkInfo) {
                        const { moduleIds } = chunkInfo;
                        let addonName;
                        for (const moduleId of moduleIds) {
                            const potentialAddonName = getAddonKeyFromChunkID(moduleId);
                            if (potentialAddonName && isAddonEntry(moduleId)) {
                                return `entries/addons/${potentialAddonName}/[name].[hash].min.js`;
                            } else if (potentialAddonName) {
                                addonName = potentialAddonName;
                            }
                        }

                        if (addonName) {
                            return `chunks/addons/${addonName}/[name].[hash].min.js`;
                        }

                        if (chunkInfo.moduleIds.includes(entryHtmlFile)) {
                            return `entries/${buildSection}.[hash].min.js`;
                        }

                        if (
                            chunkInfo.facadeModuleId?.includes("node_modules") ||
                            chunkInfo.moduleIds.map((id) => id.includes("node_modules")).reduce((a, b) => a && b, true)
                        ) {
                            return `vendor/[name].[hash].min.js`;
                        }

                        return `chunks/[name].[hash].min.js`;
                    },
                    manualChunks(id, { getModuleInfo }) {
                        const vendorPaths = [
                            "react",
                            "react-dom",
                            "react-router-dom",
                            "react-router",
                            "react-loadable",
                            "@emotion",
                            "@tanstack/react-query",
                            "@tanstack/query-core",
                            "axios",
                        ];
                        const isVendor = vendorPaths.some((vendorPath) => id.includes(`node_modules/${vendorPath}/`));
                        if (isVendor) {
                            return "vendor/react-core";
                        }

                        const reduxPaths = ["react-redux", "redux", "redux-thunk", "@reduxjs/toolkit", "immer"];
                        const isRedux = reduxPaths.some((reduxPath) => id.includes(`node_modules/${reduxPath}/`));
                        if (isRedux) {
                            return "vendor/redux";
                        }

                        const isLodash = id.includes("node_modules/lodash");
                        if (isLodash) {
                            return "vendor/lodash";
                        }

                        const platePaths = ["@udecode/plate-core", "slate"];
                        const isPlate = platePaths.some((platePath) => id.includes(`node_modules/${platePath}`));

                        if (isPlate) {
                            return "vendor/react-plate";
                        }

                        if (id.includes("node_modules/moment/")) {
                            return "vendor/moment";
                        }

                        if (id.includes("node_modules/react-select/")) {
                            return "vendor/react-select";
                        }

                        if (id.includes("node_modules/react-spring/")) {
                            return "vendor/react-spring";
                        }

                        const markdownPaths = ["micromark", "unified", "remark-parse", "micromark", "vfile"];
                        const isMarkdown = markdownPaths.some((markdownPath) =>
                            id.includes(`node_modules/${markdownPath}`),
                        );
                        if (isMarkdown) {
                            return "vendor/markdown";
                        }
                    },
                    dynamicImportInCjs: true,
                    esModule: true,
                    hoistTransitiveImports: false,
                },
            },
        },
        server: {
            host: "0.0.0.0",
            port: 3030,
            headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Origin, X-Requested-With, Content-Type, Accept",
                "Access-Control-Allow-Methods": "POST, GET, PUT, DELETE, OPTIONS",
            },
            hmr: {
                host: "127.0.0.1",
            },
            watch: {
                ignored: [
                    "**/cache/**",
                    "**/tests/**",
                    "**/vendor/**",
                    "**/docker/**",
                    "**/node_modules/**",
                    "**/.idea/**",
                    "**/.git/**",
                    "**/views/**",
                    "**/conf/**",
                ],
            },
        },
    };

    return mergeConfig(makeViteCommonConfig(), buildConfig);
}
