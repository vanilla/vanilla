{"version":3,"sources":["webpack:///./plugins/rich-editor/src/scripts/state/mention/MentionTrie.ts","webpack:///./plugins/rich-editor/src/scripts/state/mention/mentionReducer.ts","webpack:///./plugins/rich-editor/src/scripts/state/instance/instanceReducer.ts","webpack:///./plugins/rich-editor/src/scripts/state/editorReducer.ts","webpack:///./plugins/rich-editor/src/scripts/entries/forum.ts","webpack:///./build/entries/public-path.ts","webpack:///./plugins/rich-editor/src/scripts/state/mention/mentionActions.ts","webpack:///./plugins/rich-editor/src/scripts/state/instance/instanceActions.ts"],"names":["MentionTrie","this","MAX_PARTIAL_LOOKUP_ITERATIONS","root","prototype","insert","word","value","current","i","length","letter","children","contents","getNode","node","undefined","char","charAt","getValue","getValueFromPartialsOfWord","x","Math","min","substring","potentialValue","initialState","lastSuccessfulUsername","currentUsername","usersTrie","mention_MentionTrie","activeSuggestionID","activeSuggestionIndex","defaultSelection","index","instanceReducer_initialState","defaultInstance","currentSelection","lastGoodSelection","validateIDExistance","state","action","idExists","payload","editorID","type","instanceActions","Error","state_editorReducer","Object","redux","mentions","mentionActions","username","status","shouldKeepPreviousResults","previousSuccessfulName","__assign","_a","error","users","_b","searchName","looseCollator","Intl","Collator","usage","sensitivity","ignorePunctuation","numeric","sort","userA","userB","name","includes","compare","sortSuggestions","firstUserID","domID","_c","suggestionID","suggestionIndex","instances","instanceReducer_assign","selection","instanceState","application","reducerRegistry","discussionFormContainer","document","querySelectorAll","Promise","all","__webpack_require__","e","then","bind","mountEditor","sent","forEach","default","setupEditor","addEventListener","event","__awaiter","_this","container","target","Element","richEditor","querySelector","setupCommentEditForm","potentialPublicPath","window","gdn","meta","WebRoot","finalPublicPath","p","_dashboard_apiv2__WEBPACK_IMPORTED_MODULE_1__","SET_ACTIVE_SUGGESTION","LOAD_USERS_REQUEST","LOAD_USERS_FAILURE","LOAD_USERS_SUCCESS","USER_LIMIT","actions","loadUsersRequest","_dashboard_state_utility__WEBPACK_IMPORTED_MODULE_0__","loadUsersFailure","loadUsersSuccess","setActiveSuggestion","thunks","loadUsers","dispatch","getState","editor","exactLookup","partialLookup","searchCollator","filter","userSuggestion","suggestionNamePartial","filterSuggestions","params","order","limit","get","response","data","map","userID","catch","CREATE_INSTANCE","SET_SELECTION","createInstance","setSelection"],"mappings":"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","file":"/plugins/rich-editor/js/webpack/forum.min.js","sourcesContent":["/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport { IMentionSuggestionData } from \"@rich-editor/components/toolbars/pieces/MentionSuggestion\";\n\ninterface ISuccessValue {\n    status: \"SUCCESSFUL\";\n    users: IMentionSuggestionData[];\n}\n\ninterface IFailureValue {\n    status: \"FAILED\";\n    users?: null;\n    error: Error;\n}\n\ninterface IPendingValue {\n    status: \"PENDING\";\n}\n\nexport type IMentionValue = ISuccessValue | IFailureValue | IPendingValue;\n\nexport interface IMentionNode {\n    children?: {\n        [key: string]: IMentionNode;\n    };\n    value?: IMentionValue;\n}\n\n/**\n * A trie for storage of mention data.\n */\nexport default class MentionTrie {\n    public MAX_PARTIAL_LOOKUP_ITERATIONS = 10;\n    private root: IMentionNode = {};\n\n    /**\n     * Insert a value into a node for the word. This will overwrite whatever value the node already has\n     *\n     * @param word - The location in the trie.\n     * @param value - The value for the node.\n     */\n    public insert(word: string, value: IMentionValue): void {\n        let current = this.root;\n\n        for (let i = 0; i < word.length; i++) {\n            const letter = word[i];\n            if (!current.children) {\n                current.children = {};\n            }\n\n            if (!(letter in current.children)) {\n                const contents: IMentionNode = i !== word.length - 1 ? {} : { children: {} };\n                current.children[letter] = contents;\n            }\n\n            current = current.children[letter];\n        }\n\n        current.value = value;\n    }\n\n    /**\n     * Get a node for a given word.\n     *\n     * If no word is passed the root node will be returned.\n     *\n     * @param word - The word to lookup.\n     */\n    public getNode(word?: string): IMentionNode | null {\n        let node = this.root;\n        if (word === undefined) {\n            return node;\n        }\n\n        for (let i = 0; i < word.length; i++) {\n            const char = word.charAt(i);\n            if (node.children && node.children[char]) {\n                node = node.children[char];\n            } else {\n                return null;\n            }\n        }\n        return node;\n    }\n\n    /**\n     * Get the value out of a particular node.\n     *\n     * @param word - The word to lookup.\n     */\n    public getValue(word: string): IMentionValue | null {\n        const node = this.getNode(word);\n        return (node && node.value) || null;\n    }\n\n    /**\n     * Lookup the value for a word using increasingly small substrings of the current string.\n     *\n     * Number of iterations is capped at MAX_PARTIAL_LOOKUP_ITERATIONS.\n     *\n     * ex. this.getValueFormPartials(\"test\") will lookup for\n     * - \"test\",\n     * - \"tes\",\n     * - \"te\",\n     * - \"t\"\n     *\n     * And return immediately if it finds a result.\n     */\n    public getValueFromPartialsOfWord(word: string): IMentionValue | null {\n        const startingLength = Math.min(this.MAX_PARTIAL_LOOKUP_ITERATIONS, word.length);\n        for (let x = startingLength; x > 0; x--) {\n            const substring = word.substring(0, x);\n            const potentialValue = this.getValue(substring);\n            if (potentialValue != null) {\n                return potentialValue;\n            }\n        }\n\n        return null;\n    }\n}\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport * as mentionActions from \"./mentionActions\";\nimport MentionTrie from \"@rich-editor/state/mention/MentionTrie\";\nimport { IMentionSuggestionData } from \"@rich-editor/components/toolbars/pieces/MentionSuggestion\";\nimport { IMentionState } from \"@rich-editor/@types/store\";\n\nexport const initialState: IMentionState = {\n    lastSuccessfulUsername: null,\n    currentUsername: null,\n    usersTrie: new MentionTrie(),\n    activeSuggestionID: \"\",\n    activeSuggestionIndex: 0,\n};\n\nexport function sortSuggestions(users: IMentionSuggestionData[], searchName: string) {\n    const looseCollator = Intl.Collator(\"en\", {\n        usage: \"sort\",\n        sensitivity: \"variant\",\n        ignorePunctuation: true,\n        numeric: true,\n    });\n\n    return users.sort((userA, userB) => {\n        //  Return exact matches first.\n        if (userA.name.includes(searchName) && !userB.name.includes(searchName)) {\n            return -1;\n        }\n\n        if (userB.name.includes(searchName) && !userA.name.includes(searchName)) {\n            return 1;\n        }\n\n        // Then do a loose sort.\n        return looseCollator.compare(userA.name, userB.name);\n    });\n}\n\nexport default function mentionReducer(state = initialState, action: mentionActions.ActionTypes): IMentionState {\n    switch (action.type) {\n        case mentionActions.LOAD_USERS_REQUEST: {\n            const { username } = action.payload;\n            state.usersTrie.insert(username, {\n                status: \"PENDING\",\n            });\n\n            // We want to invalidate the previous results unless:\n            // - The new string is longer than the old one\n            // - The new string is a superset of the old one.\n            let shouldKeepPreviousResults = false;\n            const previousSuccessfulName = state.lastSuccessfulUsername;\n            if (previousSuccessfulName != null && username.length > previousSuccessfulName.length) {\n                const newNameSubstring = username.substring(0, previousSuccessfulName.length);\n                if (newNameSubstring === previousSuccessfulName) {\n                    shouldKeepPreviousResults = true;\n                }\n            }\n\n            return {\n                ...state,\n                currentUsername: username,\n                lastSuccessfulUsername: shouldKeepPreviousResults ? state.lastSuccessfulUsername : null,\n            };\n        }\n        case mentionActions.LOAD_USERS_FAILURE: {\n            const { username, error } = action.payload;\n            state.usersTrie.insert(username, {\n                status: \"FAILED\",\n                users: null,\n                error,\n            });\n            return state;\n        }\n        case mentionActions.LOAD_USERS_SUCCESS: {\n            const { username, users } = action.payload;\n            state.usersTrie.insert(username, {\n                status: \"SUCCESSFUL\",\n                users: sortSuggestions(users, username),\n            });\n\n            const firstUserID = users.length > 0 ? users[0].domID : \"\";\n            return {\n                ...state,\n                activeSuggestionID: firstUserID,\n                activeSuggestionIndex: 0,\n                lastSuccessfulUsername: username,\n                currentUsername: username === state.currentUsername ? null : state.currentUsername,\n            };\n        }\n        case mentionActions.SET_ACTIVE_SUGGESTION: {\n            const { suggestionID, suggestionIndex } = action.payload;\n            return {\n                ...state,\n                activeSuggestionID: suggestionID,\n                activeSuggestionIndex: suggestionIndex,\n            };\n        }\n        default:\n            return state;\n    }\n}\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport * as instanceActions from \"./instanceActions\";\nimport { IEditorInstanceState, IEditorInstance } from \"@rich-editor/@types/store\";\n\nconst defaultSelection = {\n    index: 0,\n    length: 0,\n};\n\nexport const initialState: IEditorInstanceState = {};\nexport const defaultInstance: IEditorInstance = {\n    currentSelection: defaultSelection,\n    lastGoodSelection: defaultSelection,\n};\n\n/**\n * Validate that an particular editor ID has been created before certain actions are taken on it.\n */\nfunction validateIDExistance(state: IEditorInstanceState, action: instanceActions.ActionTypes) {\n    const idExists = state[action.payload.editorID];\n    if (action.type === instanceActions.CREATE_INSTANCE && idExists) {\n        throw new Error(`Failed to create editor instance with id ${action.payload.editorID}. Id already exists`);\n    }\n\n    if (action.type !== instanceActions.CREATE_INSTANCE && !idExists) {\n        throw new Error(\n            `Could not perform an action for editor ID ${\n                action.payload.editorID\n            } that doesn't exist. Be sure to create an instance first.`,\n        );\n    }\n}\n\nexport default function instanceReducer(\n    state = initialState,\n    action: instanceActions.ActionTypes,\n): IEditorInstanceState {\n    switch (action.type) {\n        case instanceActions.CREATE_INSTANCE: {\n            validateIDExistance(state, action);\n            return {\n                ...state,\n                [action.payload.editorID]: defaultInstance,\n            };\n        }\n        case instanceActions.SET_SELECTION: {\n            validateIDExistance(state, action);\n            const { selection, editorID } = action.payload;\n            const instanceState = state[editorID];\n            const { lastGoodSelection } = instanceState;\n            return {\n                ...state,\n                [editorID]: {\n                    ...instanceState,\n                    currentSelection: selection,\n                    lastGoodSelection: selection !== null ? selection : lastGoodSelection,\n                },\n            };\n        }\n        default: {\n            return state;\n        }\n    }\n}\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport mentionReducer from \"./mention/mentionReducer\";\nimport instanceReducer from \"./instance/instanceReducer\";\nimport { combineReducers } from \"redux\";\n\nconst editorReducer = combineReducers({\n    mentions: mentionReducer,\n    instances: instanceReducer,\n});\n\nexport default editorReducer;\n","/*\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport { registerReducer } from \"@dashboard/state/reducerRegistry\";\nimport editorReducer from \"@rich-editor/state/editorReducer\";\nimport { onReady } from \"@dashboard/application\";\n\nonReady(() => {\n    registerReducer(\"editor\", editorReducer);\n    void setupEditor();\n    void setupCommentEditForm();\n});\n\n/**\n * Set up the new discussion form if it exists.\n */\nasync function setupEditor() {\n    const discussionFormContainer = document.querySelectorAll(\".richEditor\");\n    if (discussionFormContainer.length > 0) {\n        const mountEditor = await import(/* webpackChunkName: \"plugins/rich-editor/js/webpack/chunks/mountEditor\" */ \"@rich-editor/mountEditor\");\n        discussionFormContainer.forEach(mountEditor.default);\n    }\n}\n\n/**\n * Set up the editor if the someone clicks edit on a form.\n */\nasync function setupCommentEditForm() {\n    document.addEventListener(\"X-EditCommentFormLoaded\", async event => {\n        const container = event.target;\n        if (!(container instanceof Element)) {\n            return;\n        }\n\n        const richEditor = container.querySelector(\".richEditor\");\n        if (richEditor) {\n            const mountEditor = await import(/* webpackChunkName: \"plugins/rich-editor/js/webpack/chunks/mountEditor\" */ \"@rich-editor/mountEditor\");\n            mountEditor.default(richEditor);\n        }\n    });\n}\n","/**\n * Set wepback's public path.\n * Otherwise the lookups of dynamically imported webpack files can fail on sites that have a different webroot\n * Eg. installed in a subfolder / using Reverse Proxy.\n *\n * @author Adam Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license http://www.opensource.org/licenses/gpl-2.0.php GNU GPL v2\n */\n\nconst potentialPublicPath = window.gdn && window.gdn.meta && window.gdn.meta.WebRoot;\nconst finalPublicPath = potentialPublicPath != null ? potentialPublicPath : \"/\";\n\n/**\n * This needs to be a free variable.\n *\n * Webpack does some magic to make this work.\n * It you try and set a local or global version of it, it WILL NOT work.\n *\n * @see https://stackoverflow.com/questions/12934929/what-are-free-variables\n * @see https://webpack.js.org/configuration/output/#output-publicpath\n * @see https://github.com/webpack/webpack/issues/2776#issuecomment-233208623\n */\n// @ts-ignore: Cannot find variable warning. See comment aboe.\n__webpack_public_path__ = finalPublicPath;\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport { Dispatch } from \"redux\";\nimport { ActionsUnion, createAction } from \"@dashboard/state/utility\";\nimport api from \"@dashboard/apiv2\";\nimport { IMentionSuggestionData } from \"@rich-editor/components/toolbars/pieces/MentionSuggestion\";\nimport { IStoreState } from \"@rich-editor/@types/store\";\n\nexport const SET_ACTIVE_SUGGESTION = \"[mentions] set active suggestion\";\nexport const LOAD_USERS_REQUEST = \"[mentions] load users request\";\nexport const LOAD_USERS_FAILURE = \"[mentions] load users failure\";\nexport const LOAD_USERS_SUCCESS = \"[mentions] load users success\";\n\n// The number of characters that we will lookup to try and invalidate a lookup early.\nconst USER_LIMIT = 50;\n\n/**\n * Filter users down to a list that loosely matches the current searchName\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator\n */\nexport function filterSuggestions(users: IMentionSuggestionData[], searchName: string) {\n    const searchCollator = Intl.Collator(\"en\", {\n        usage: \"search\",\n        sensitivity: \"base\",\n        ignorePunctuation: true,\n        numeric: true,\n    });\n\n    return users.filter((userSuggestion: IMentionSuggestionData) => {\n        if (userSuggestion.name.length < searchName.length) {\n            return false;\n        }\n\n        const suggestionNamePartial = userSuggestion.name.substring(0, searchName.length);\n        return searchCollator.compare(suggestionNamePartial, searchName) === 0;\n    });\n}\n\n// export function should;\n\n/**\n * Make an API request for mention suggestions. These results are cached by the lookup username.\n */\nfunction loadUsers(username: string) {\n    return (dispatch: Dispatch<any>, getState: () => IStoreState) => {\n        const { usersTrie } = getState().editor.mentions;\n\n        // Attempt an exact lookup first.\n        const exactLookup = usersTrie.getValue(username);\n        if (exactLookup != null) {\n            switch (exactLookup.status) {\n                case \"SUCCESSFUL\":\n                    return dispatch(actions.loadUsersSuccess(username, exactLookup.users));\n                case \"PENDING\":\n                    // Already working on it.\n                    return;\n                case \"FAILED\":\n                    // Previously failed.\n                    return dispatch(actions.loadUsersFailure(username, exactLookup.error));\n            }\n        }\n\n        // Attempt a partial lookup to try and see if we can get results without an API request\n        const partialLookup = usersTrie.getValueFromPartialsOfWord(username);\n        if (partialLookup != null) {\n            switch (partialLookup.status) {\n                case \"SUCCESSFUL\": {\n                    if (partialLookup.users.length < USER_LIMIT) {\n                        // The previous match already found the maximum amount of users that the server had\n                        // Return the previous results.\n                        return dispatch(\n                            actions.loadUsersSuccess(username, filterSuggestions(partialLookup.users, username)),\n                        );\n                    }\n                }\n                case \"FAILED\":\n                // Previously failed. We still want to proceed to a real lookup so do nothing.\n                case \"PENDING\":\n                // We still want to proceed to a real lookup so do nothing.\n            }\n        }\n\n        // Start the lookup.\n        dispatch(actions.loadUsersRequest(username));\n\n        const params = {\n            name: username + \"*\",\n            order: \"mention\",\n            limit: USER_LIMIT,\n        };\n        return api\n            .get(\"/users/by-names/\", { params /*, cancelToken: this.apiCancelSource.token*/ })\n            .then(response => {\n                if (response.status >= 500) {\n                    throw new Error(response.data);\n                }\n\n                // Add unique domIDs to each user.\n                const users = response.data.map(data => {\n                    data.domID = \"mentionSuggestion\" + data.userID;\n                    return data;\n                });\n\n                // Result is good. Lets GO!\n                dispatch(actions.loadUsersSuccess(username, users));\n            })\n            .catch(error => dispatch(actions.loadUsersFailure(username, error)));\n    };\n}\n\nexport const actions = {\n    loadUsersRequest: (username: string) => createAction(LOAD_USERS_REQUEST, { username }),\n    loadUsersFailure: (username: string, error: Error) => createAction(LOAD_USERS_FAILURE, { username, error }),\n    loadUsersSuccess: (username: string, users: IMentionSuggestionData[]) =>\n        createAction(LOAD_USERS_SUCCESS, { username, users }),\n    setActiveSuggestion: (suggestionID: string, suggestionIndex: number) =>\n        createAction(SET_ACTIVE_SUGGESTION, { suggestionID, suggestionIndex }),\n};\n\nexport const thunks = {\n    loadUsers,\n};\n\nexport type ActionTypes = ActionsUnion<typeof actions>;\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport { ActionsUnion, createAction } from \"@dashboard/state/utility\";\nimport { RangeStatic } from \"quill/core\";\n\nexport const CREATE_INSTANCE = \"[instance] create\";\nexport const SET_SELECTION = \"[instance] set selection\";\n\nexport const actions = {\n    createInstance: (editorID: string | number) => createAction(CREATE_INSTANCE, { editorID }),\n    setSelection: (editorID: string | number, selection: RangeStatic | null) =>\n        createAction(SET_SELECTION, { editorID, selection }),\n};\n\nexport type ActionTypes = ActionsUnion<typeof actions>;\n"],"sourceRoot":""}